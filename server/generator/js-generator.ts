import { templateEngine } from "./template-engine";
import type { EffectAnalysis } from "@shared/schema";

interface GenerationOptions {
  performance?: string;
  platform?: string;
  optimization?: boolean;
  comments?: boolean;
  minify?: boolean;
}

class JSGenerator {
  async generate(
    description: string,
    analysis: EffectAnalysis,
    modules: any[],
    options: GenerationOptions = {}
  ): Promise<string> {
    try {
      // Determine the primary effect type
      const primaryModule = modules[0];
      const effectType = this.determineEffectType(analysis, primaryModule);
      
      // Generate the effect class
      const effectClass = await this.generateEffectClass(
        description,
        analysis,
        modules,
        effectType,
        options
      );
      
      // Add utility functions if needed
      const utilities = this.generateUtilities(modules, options);
      
      // Combine everything
      let generatedCode = this.generateHeader(description, analysis, options);
      generatedCode += utilities;
      generatedCode += effectClass;
      generatedCode += this.generateUsageExample(effectType, analysis, options);
      
      // Apply optimizations
      if (options.optimization !== false) {
        generatedCode = this.optimizeCode(generatedCode, options);
      }
      
      // Minify if requested
      if (options.minify) {
        generatedCode = this.minifyCode(generatedCode);
      }
      
      return generatedCode;
    } catch (error) {
      console.error("JS generation error:", error);
      throw new Error(`Failed to generate JavaScript code: ${error instanceof Error ? error.message : 'Unknown error'}`);
    }
  }

  private determineEffectType(analysis: EffectAnalysis, primaryModule: any): string {
    if (primaryModule) {
      return primaryModule.getName();
    }
    
    // Fallback based on concepts
    if (analysis.concepts.includes('particles') || analysis.concepts.includes('explosion')) {
      return 'particles';
    }
    if (analysis.concepts.includes('morph') || analysis.concepts.includes('transform')) {
      return 'morphing';
    }
    if (analysis.concepts.includes('light') || analysis.concepts.includes('glow')) {
      return 'lighting';
    }
    if (analysis.concepts.includes('physics') || analysis.concepts.includes('gravity')) {
      return 'physics';
    }
    
    return 'particles'; // Default fallback
  }

  private generateHeader(description: string, analysis: EffectAnalysis, options: GenerationOptions): string {
    if (options.comments === false) return '';
    
    return `/*
 * Auto-generated by EffectForge AI
 * Effect: ${description}
 * Generated: ${new Date().toISOString()}
 * Complexity: ${analysis.complexity}/10
 * Confidence: ${Math.round(analysis.confidence * 100)}%
 * Modules: ${analysis.modules.join(', ')}
 * 
 * Performance Target: ${options.performance || 'medium'}
 * Platform: ${options.platform || 'web'}
 */

`;
  }

  private async generateEffectClass(
    description: string,
    analysis: EffectAnalysis,
    modules: any[],
    effectType: string,
    options: GenerationOptions
  ): Promise<string> {
    const className = this.generateClassName(description);
    const config = this.buildModuleConfig(analysis, modules, options);
    
    // Get the primary module code
    const primaryModule = modules.find(m => m.getName() === effectType) || modules[0];
    let moduleCode = '';
    
    if (primaryModule && typeof primaryModule.generateCode === 'function') {
      moduleCode = primaryModule.generateCode(config);
    } else {
      // Generate basic effect code
      moduleCode = await this.generateBasicEffect(effectType, config, options);
    }
    
    // Enhance with additional modules
    const enhancedCode = this.enhanceWithModules(moduleCode, modules.slice(1), config, options);
    
    return enhancedCode;
  }

  private generateClassName(description: string): string {
    // Convert description to a valid class name
    return description
      .replace(/[^a-zA-Z0-9\s]/g, '')
      .split(' ')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
      .join('')
      .slice(0, 50) + 'Effect';
  }

  private buildModuleConfig(analysis: EffectAnalysis, modules: any[], options: GenerationOptions): any {
    const config: any = {
      performance: options.performance || 'medium',
      platform: options.platform || 'web'
    };

    // Map analysis parameters to module configs
    Object.keys(analysis.parameters).forEach(key => {
      config[key] = analysis.parameters[key];
    });

    // Performance adjustments
    if (options.performance === 'high') {
      config.particleCount = Math.min(config.particleCount || 100, 300);
      config.quality = 'high';
      config.targetFPS = 60;
    } else if (options.performance === 'low') {
      config.particleCount = Math.min(config.particleCount || 100, 50);
      config.quality = 'low';
      config.targetFPS = 30;
    }

    return config;
  }

  private async generateBasicEffect(effectType: string, config: any, options: GenerationOptions): Promise<string> {
    const template = await templateEngine.getTemplate(effectType);
    return templateEngine.processTemplate(template, config);
  }

  private enhanceWithModules(baseCode: string, additionalModules: any[], config: any, options: GenerationOptions): string {
    let enhancedCode = baseCode;
    
    additionalModules.forEach(module => {
      const moduleName = module.getName();
      
      // Add module-specific enhancements
      switch (moduleName) {
        case 'physics':
          enhancedCode = this.addPhysicsEnhancements(enhancedCode, config);
          break;
        case 'lighting':
          enhancedCode = this.addLightingEnhancements(enhancedCode, config);
          break;
        case 'morphing':
          enhancedCode = this.addMorphingEnhancements(enhancedCode, config);
          break;
      }
    });
    
    return enhancedCode;
  }

  private addPhysicsEnhancements(code: string, config: any): string {
    // Add physics integration
    const physicsIntegration = `
  
  // Physics Integration
  initPhysics() {
    this.physics = {
      gravity: ${config.gravity || 0.2},
      damping: ${config.damping || 0.99},
      bounce: ${config.bounce || 0.8}
    };
  }
  
  applyPhysics(particle) {
    if (this.physics) {
      particle.vy += this.physics.gravity;
      particle.vx *= this.physics.damping;
      particle.vy *= this.physics.damping;
      
      // Boundary collision
      if (particle.y + particle.radius > this.canvas.height) {
        particle.y = this.canvas.height - particle.radius;
        particle.vy *= -this.physics.bounce;
      }
    }
  }`;
    
    return code.replace('constructor(canvas, options = {}) {', 
      'constructor(canvas, options = {}) {\n    this.initPhysics();') + physicsIntegration;
  }

  private addLightingEnhancements(code: string, config: any): string {
    const lightingIntegration = `
  
  // Lighting Integration
  initLighting() {
    this.lighting = {
      ambient: ${config.ambient || 0.2},
      intensity: ${config.lightIntensity || 0.8},
      color: "${config.lightColor || '#ffffff'}"
    };
  }
  
  applyLighting(particle) {
    if (this.lighting) {
      // Add glow effect
      this.ctx.shadowColor = particle.color;
      this.ctx.shadowBlur = particle.size * this.lighting.intensity;
    }
  }`;
    
    return code.replace('constructor(canvas, options = {}) {', 
      'constructor(canvas, options = {}) {\n    this.initLighting();') + lightingIntegration;
  }

  private addMorphingEnhancements(code: string, config: any): string {
    const morphingIntegration = `
  
  // Morphing Integration
  initMorphing() {
    this.morphing = {
      enabled: ${config.morphing || false},
      speed: ${config.morphSpeed || 1.0},
      shapes: ${JSON.stringify(config.shapes || ['circle', 'square'])}
    };
    this.morphTime = 0;
  }
  
  applyMorphing(particle) {
    if (this.morphing && this.morphing.enabled) {
      this.morphTime += 0.01 * this.morphing.speed;
      const morphFactor = (Math.sin(this.morphTime) + 1) / 2;
      particle.size = particle.originalSize * (0.5 + morphFactor * 0.5);
    }
  }`;
    
    return code.replace('constructor(canvas, options = {}) {', 
      'constructor(canvas, options = {}) {\n    this.initMorphing();') + morphingIntegration;
  }

  private generateUtilities(modules: any[], options: GenerationOptions): string {
    if (options.comments === false) return '';
    
    return `
// Utility Functions
const EffectUtils = {
  lerp: (start, end, factor) => start + (end - start) * factor,
  
  clamp: (value, min, max) => Math.min(Math.max(value, min), max),
  
  random: (min, max) => Math.random() * (max - min) + min,
  
  randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1)) + min,
  
  distance: (x1, y1, x2, y2) => Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2),
  
  angle: (x1, y1, x2, y2) => Math.atan2(y2 - y1, x2 - x1),
  
  hexToRgb: (hex) => {
    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  },
  
  rgbToHex: (r, g, b) => \`#\${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}\`
};

`;
  }

  private generateUsageExample(effectType: string, analysis: EffectAnalysis, options: GenerationOptions): string {
    if (options.comments === false) return '';
    
    const className = this.generateClassName('CustomEffect');
    
    return `
/*
 * Usage Example:
 * 
 * const canvas = document.getElementById('effectCanvas');
 * const effect = new ${className}(canvas, {
 *   particleCount: ${analysis.parameters.particleCount || 100},
 *   intensity: ${analysis.parameters.intensity || 0.8}
 * });
 * 
 * function animate() {
 *   effect.update();
 *   effect.render();
 *   requestAnimationFrame(animate);
 * }
 * 
 * // Trigger the effect
 * effect.start();
 * animate();
 */
`;
  }

  private optimizeCode(code: string, options: GenerationOptions): string {
    let optimized = code;
    
    // Remove unnecessary whitespace (but preserve functionality)
    optimized = optimized.replace(/\n\s*\n\s*\n/g, '\n\n'); // Remove excessive line breaks
    
    // Optimize for performance target
    if (options.performance === 'high') {
      // Add performance hints
      optimized = optimized.replace(
        'render() {',
        'render() {\n    // Optimized for 60fps performance'
      );
    }
    
    return optimized;
  }

  private minifyCode(code: string): string {
    // Simple minification (in production, use a proper minifier)
    return code
      .replace(/\/\*[\s\S]*?\*\//g, '') // Remove comments
      .replace(/\/\/.*$/gm, '') // Remove single-line comments
      .replace(/\s+/g, ' ') // Collapse whitespace
      .replace(/;\s*}/g, ';}') // Remove unnecessary semicolons
      .trim();
  }
}

export const jsGenerator = new JSGenerator();
